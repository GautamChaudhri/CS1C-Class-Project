<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>2D Graphics Modeler - Team Alphawolves: Parser Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">2D Graphics Modeler - Team Alphawolves
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/db7/class_parser.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="../../de/d9d/class_parser-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Parser Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides functionality for parsing JSON data to C++ objects and vice-versa.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/d40/_parser_8h_source.html">Parser.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html">MorphicShape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal accumulator structure for parsing shape data from JSON.  <a href="../../de/d34/struct_parser_1_1_morphic_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d30/struct_parser_1_1_raw_user.html">RawUser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal accumulator structure for parsing user account data from JSON.  <a href="../../da/d30/struct_parser_1_1_raw_user.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5208129b497bfdf7c8ecceeb70e4bba8" id="r_a5208129b497bfdf7c8ecceeb70e4bba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5208129b497bfdf7c8ecceeb70e4bba8">Parser</a> ()=default</td></tr>
<tr class="memdesc:a5208129b497bfdf7c8ecceeb70e4bba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Initializes a <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> object.  <br /></td></tr>
<tr class="separator:a5208129b497bfdf7c8ecceeb70e4bba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95734193a58a199b4c6d820a6a730c42" id="r_a95734193a58a199b4c6d820a6a730c42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95734193a58a199b4c6d820a6a730c42">~Parser</a> ()=default</td></tr>
<tr class="memdesc:a95734193a58a199b4c6d820a6a730c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. Cleans up resources used by the <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> object.  <br /></td></tr>
<tr class="separator:a95734193a58a199b4c6d820a6a730c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48044a8caa14a251cb4dad9fb363658e" id="r_a48044a8caa14a251cb4dad9fb363658e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48044a8caa14a251cb4dad9fb363658e">Parser</a> (const <a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;)=delete</td></tr>
<tr class="memdesc:a48044a8caa14a251cb4dad9fb363658e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor to prevent copying <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects.  <br /></td></tr>
<tr class="separator:a48044a8caa14a251cb4dad9fb363658e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4492f2702ae0fc9e5b23a2fa546ee7f3" id="r_a4492f2702ae0fc9e5b23a2fa546ee7f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4492f2702ae0fc9e5b23a2fa546ee7f3">operator=</a> (const <a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;)=delete</td></tr>
<tr class="memdesc:a4492f2702ae0fc9e5b23a2fa546ee7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator to prevent copying <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects.  <br /></td></tr>
<tr class="separator:a4492f2702ae0fc9e5b23a2fa546ee7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd10e8fbc4e04201570a437198d8c61" id="r_aacd10e8fbc4e04201570a437198d8c61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacd10e8fbc4e04201570a437198d8c61">Parser</a> (<a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:aacd10e8fbc4e04201570a437198d8c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor to prevent moving <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects.  <br /></td></tr>
<tr class="separator:aacd10e8fbc4e04201570a437198d8c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbcdfe39e81929129e00fba8b546ed9" id="r_adfbcdfe39e81929129e00fba8b546ed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfbcdfe39e81929129e00fba8b546ed9">operator=</a> (<a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:adfbcdfe39e81929129e00fba8b546ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator to prevent moving <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects.  <br /></td></tr>
<tr class="separator:adfbcdfe39e81929129e00fba8b546ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae118a7f13833108b4f01902af8a260b8" id="r_ae118a7f13833108b4f01902af8a260b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae118a7f13833108b4f01902af8a260b8">PrintShapeVector</a> (const <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d7/da7/class_shape.html">Shape</a> * &gt; &amp;shapes)</td></tr>
<tr class="memdesc:ae118a7f13833108b4f01902af8a260b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints properties of shapes in a vector to the console.  <br /></td></tr>
<tr class="separator:ae118a7f13833108b4f01902af8a260b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4bd21d0d23be70682e026d6e702ec9" id="r_a9c4bd21d0d23be70682e026d6e702ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d7/da7/class_shape.html">Shape</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c4bd21d0d23be70682e026d6e702ec9">JsonToShapes</a> (const std::string &amp;json)</td></tr>
<tr class="memdesc:a9c4bd21d0d23be70682e026d6e702ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a JSON string representation into a vector of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> objects.  <br /></td></tr>
<tr class="separator:a9c4bd21d0d23be70682e026d6e702ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc74d228421b62ece9d9e93511509e" id="r_ac0dc74d228421b62ece9d9e93511509e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0dc74d228421b62ece9d9e93511509e">ShapesToJson</a> (const <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d7/da7/class_shape.html">Shape</a> * &gt; &amp;shapes)</td></tr>
<tr class="memdesc:ac0dc74d228421b62ece9d9e93511509e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> pointers into a JSON string representation.  <br /></td></tr>
<tr class="separator:ac0dc74d228421b62ece9d9e93511509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c6d8559fd28407b48e9eef05496d8" id="r_a7e0c6d8559fd28407b48e9eef05496d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d3/d9d/class_user_account.html">UserAccount</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e0c6d8559fd28407b48e9eef05496d8">JsonToUsers</a> (const std::string &amp;json)</td></tr>
<tr class="memdesc:a7e0c6d8559fd28407b48e9eef05496d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a JSON string representation into a vector of <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> objects.  <br /></td></tr>
<tr class="separator:a7e0c6d8559fd28407b48e9eef05496d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec700c3508cbac1197ff4010160be3cb" id="r_aec700c3508cbac1197ff4010160be3cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec700c3508cbac1197ff4010160be3cb">UsersToJson</a> (const <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d3/d9d/class_user_account.html">UserAccount</a> * &gt; &amp;users)</td></tr>
<tr class="memdesc:aec700c3508cbac1197ff4010160be3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> pointers into a JSON string representation.  <br /></td></tr>
<tr class="separator:aec700c3508cbac1197ff4010160be3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afde14aac82ddca80d32462cc085e71d9" id="r_afde14aac82ddca80d32462cc085e71d9"><td class="memItemLeft" align="right" valign="top">static QVector&lt; <a class="el" href="../../d4/dc3/class_testimonial.html">Testimonial</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afde14aac82ddca80d32462cc085e71d9">JsonToTestimonials</a> (const std::string &amp;json)</td></tr>
<tr class="memdesc:afde14aac82ddca80d32462cc085e71d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a JSON string representation into a QVector of <a class="el" href="../../d4/dc3/class_testimonial.html" title="Represents a user testimonial.">Testimonial</a> objects.  <br /></td></tr>
<tr class="separator:afde14aac82ddca80d32462cc085e71d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a8828ed47a09c969ed966865da186d" id="r_a37a8828ed47a09c969ed966865da186d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37a8828ed47a09c969ed966865da186d">TestimonialsToJson</a> (const QVector&lt; <a class="el" href="../../d4/dc3/class_testimonial.html">Testimonial</a> &gt; &amp;testimonials)</td></tr>
<tr class="memdesc:a37a8828ed47a09c969ed966865da186d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a QVector of <a class="el" href="../../d4/dc3/class_testimonial.html" title="Represents a user testimonial.">Testimonial</a> objects into a JSON string representation.  <br /></td></tr>
<tr class="separator:a37a8828ed47a09c969ed966865da186d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4d2c4035d6109be0ceca773cfbcff523" id="r_a4d2c4035d6109be0ceca773cfbcff523"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html">MorphicShape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d2c4035d6109be0ceca773cfbcff523">ParseJsonObject</a> (const std::string json, size_t &amp;index)</td></tr>
<tr class="memdesc:a4d2c4035d6109be0ceca773cfbcff523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single JSON object (data within '{}') into a <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a>.  <br /></td></tr>
<tr class="separator:a4d2c4035d6109be0ceca773cfbcff523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bb64fa743348c1b31eb1118c6d4e0f" id="r_ac3bb64fa743348c1b31eb1118c6d4e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3bb64fa743348c1b31eb1118c6d4e0f">UpdateAccumulator</a> (const std::string &amp;key, const std::string &amp;value, <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html">MorphicShape</a> &amp;tempShape)</td></tr>
<tr class="memdesc:ac3bb64fa743348c1b31eb1118c6d4e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> accumulator with a parsed key-value pair.  <br /></td></tr>
<tr class="separator:ac3bb64fa743348c1b31eb1118c6d4e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991032ca21e8e64a0fa274b8056cc669" id="r_a991032ca21e8e64a0fa274b8056cc669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/da7/class_shape.html">Shape</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991032ca21e8e64a0fa274b8056cc669">BuildShape</a> (<a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html">MorphicShape</a> tempShape)</td></tr>
<tr class="memdesc:a991032ca21e8e64a0fa274b8056cc669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a concrete <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object from a populated <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> accumulator.  <br /></td></tr>
<tr class="separator:a991032ca21e8e64a0fa274b8056cc669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fad6dc437bab644ea477090320cbe8" id="r_a49fad6dc437bab644ea477090320cbe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49fad6dc437bab644ea477090320cbe8">SkipWhitespace</a> (const std::string &amp;json, size_t &amp;index)</td></tr>
<tr class="memdesc:a49fad6dc437bab644ea477090320cbe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the parsing index past any whitespace characters.  <br /></td></tr>
<tr class="separator:a49fad6dc437bab644ea477090320cbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6658bb70a8b63f8edab2c0a6c7c65d9a" id="r_a6658bb70a8b63f8edab2c0a6c7c65d9a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6658bb70a8b63f8edab2c0a6c7c65d9a">ExtractKey</a> (const std::string &amp;json, size_t &amp;index)</td></tr>
<tr class="memdesc:a6658bb70a8b63f8edab2c0a6c7c65d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a JSON key (a string enclosed in double quotes) from the input string.  <br /></td></tr>
<tr class="separator:a6658bb70a8b63f8edab2c0a6c7c65d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9641ed520d4e9b73600e3cc049af46" id="r_ade9641ed520d4e9b73600e3cc049af46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade9641ed520d4e9b73600e3cc049af46">ExtractValue</a> (const std::string &amp;json, size_t &amp;index)</td></tr>
<tr class="memdesc:ade9641ed520d4e9b73600e3cc049af46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a JSON value from the input string.  <br /></td></tr>
<tr class="separator:ade9641ed520d4e9b73600e3cc049af46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30398a0f28f70626124609a1071f7f60" id="r_a30398a0f28f70626124609a1071f7f60"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30398a0f28f70626124609a1071f7f60">ExtractInteger</a> (const std::string &amp;json, size_t &amp;index)</td></tr>
<tr class="memdesc:a30398a0f28f70626124609a1071f7f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an integer value from the JSON string.  <br /></td></tr>
<tr class="separator:a30398a0f28f70626124609a1071f7f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabd71dccc533b85de37e566cda47abe" id="r_acabd71dccc533b85de37e566cda47abe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acabd71dccc533b85de37e566cda47abe">ExtractArray</a> (const std::string &amp;json, size_t &amp;index)</td></tr>
<tr class="memdesc:acabd71dccc533b85de37e566cda47abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a JSON array (content within '[]') as a string.  <br /></td></tr>
<tr class="separator:acabd71dccc533b85de37e566cda47abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbc99f343ea14baa4e3c8d84066b83e" id="r_a9dbc99f343ea14baa4e3c8d84066b83e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dbc99f343ea14baa4e3c8d84066b83e">ExtractLiteral</a> (const std::string &amp;json, size_t &amp;index)</td></tr>
<tr class="memdesc:a9dbc99f343ea14baa4e3c8d84066b83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a JSON literal (true, false, null) as a string.  <br /></td></tr>
<tr class="separator:a9dbc99f343ea14baa4e3c8d84066b83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4c2a3664d2d2c1f5444c18271a1cf4" id="r_a0a4c2a3664d2d2c1f5444c18271a1cf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a4c2a3664d2d2c1f5444c18271a1cf4">StringToVector</a> (const std::string &amp;value)</td></tr>
<tr class="memdesc:a0a4c2a3664d2d2c1f5444c18271a1cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string representation of a JSON array of integers into an <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector&lt;int&gt;</a>.  <br /></td></tr>
<tr class="separator:a0a4c2a3664d2d2c1f5444c18271a1cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8932bed758cd3e61de3669fdef1110" id="r_a8f8932bed758cd3e61de3669fdef1110"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f8932bed758cd3e61de3669fdef1110">AppendCommonShapeData</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:a8f8932bed758cd3e61de3669fdef1110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends common shape properties (ID, Type, Dimensions, Pen properties) to a JSON string.  <br /></td></tr>
<tr class="separator:a8f8932bed758cd3e61de3669fdef1110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4947ae95392cd961660d9202d4c12e5e" id="r_a4947ae95392cd961660d9202d4c12e5e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4947ae95392cd961660d9202d4c12e5e">AppendBrushData</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:a4947ae95392cd961660d9202d4c12e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends QBrush properties (BrushColor, BrushStyle) to a JSON string.  <br /></td></tr>
<tr class="separator:a4947ae95392cd961660d9202d4c12e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8d6dcf6e07231eaedb036ebe90b51f" id="r_a3c8d6dcf6e07231eaedb036ebe90b51f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c8d6dcf6e07231eaedb036ebe90b51f">AppendTextData</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:a3c8d6dcf6e07231eaedb036ebe90b51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends all properties specific to <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> objects to a JSON string.  <br /></td></tr>
<tr class="separator:a3c8d6dcf6e07231eaedb036ebe90b51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246a0732ef6c7518e5aaee1043d12e4" id="r_af246a0732ef6c7518e5aaee1043d12e4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af246a0732ef6c7518e5aaee1043d12e4">GetShapeDimensions</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:af246a0732ef6c7518e5aaee1043d12e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the geometric dimensions of a shape as a JSON array string.  <br /></td></tr>
<tr class="separator:af246a0732ef6c7518e5aaee1043d12e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873d052551342d31e66e6746b09d2fe9" id="r_a873d052551342d31e66e6746b09d2fe9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a873d052551342d31e66e6746b09d2fe9">GetColor</a> (const QColor &amp;objectColor)</td></tr>
<tr class="memdesc:a873d052551342d31e66e6746b09d2fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a QColor object to its string representation (e.g., "red", "blue").  <br /></td></tr>
<tr class="separator:a873d052551342d31e66e6746b09d2fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af303a9796fe246709fd2da137248e6d2" id="r_af303a9796fe246709fd2da137248e6d2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af303a9796fe246709fd2da137248e6d2">GetPenStyle</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:af303a9796fe246709fd2da137248e6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pen style of a shape as a string (e.g., "SolidLine", "DashLine").  <br /></td></tr>
<tr class="separator:af303a9796fe246709fd2da137248e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc8c1d3938f5f55be6074830f96090e" id="r_a4cc8c1d3938f5f55be6074830f96090e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cc8c1d3938f5f55be6074830f96090e">GetPenCapStyle</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:a4cc8c1d3938f5f55be6074830f96090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pen cap style of a shape as a string (e.g., "FlatCap", "RoundCap").  <br /></td></tr>
<tr class="separator:a4cc8c1d3938f5f55be6074830f96090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb18c8e63721594a5ee98f94e160c3" id="r_aacdb18c8e63721594a5ee98f94e160c3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacdb18c8e63721594a5ee98f94e160c3">GetPenJoinStyle</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:aacdb18c8e63721594a5ee98f94e160c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pen join style of a shape as a string (e.g., "MiterJoin", "BevelJoin").  <br /></td></tr>
<tr class="separator:aacdb18c8e63721594a5ee98f94e160c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae1381ec08a2e3b54077c753d4dbf34" id="r_a2ae1381ec08a2e3b54077c753d4dbf34"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ae1381ec08a2e3b54077c753d4dbf34">GetBrushStyle</a> (const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *shape)</td></tr>
<tr class="memdesc:a2ae1381ec08a2e3b54077c753d4dbf34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the brush style of a shape as a string (e.g., "SolidPattern", "NoBrush").  <br /></td></tr>
<tr class="separator:a2ae1381ec08a2e3b54077c753d4dbf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f89825a62c101002365cdc06188b0b" id="r_a34f89825a62c101002365cdc06188b0b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34f89825a62c101002365cdc06188b0b">GetAlignmentFlag</a> (const <a class="el" href="../../da/d0e/class_text.html">Text</a> *text)</td></tr>
<tr class="memdesc:a34f89825a62c101002365cdc06188b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the text alignment of a <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object as a string (e.g., "AlignLeft", "AlignCenter").  <br /></td></tr>
<tr class="separator:a34f89825a62c101002365cdc06188b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772810a8efbdda40d51d9a81125a45c0" id="r_a772810a8efbdda40d51d9a81125a45c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a772810a8efbdda40d51d9a81125a45c0">GetFontStyle</a> (const <a class="el" href="../../da/d0e/class_text.html">Text</a> *text)</td></tr>
<tr class="memdesc:a772810a8efbdda40d51d9a81125a45c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the font style of a <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object as a string (e.g., "StyleNormal", "StyleItalic").  <br /></td></tr>
<tr class="separator:a772810a8efbdda40d51d9a81125a45c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8599ff5bde69ad1ceb08f81b955539d" id="r_ae8599ff5bde69ad1ceb08f81b955539d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8599ff5bde69ad1ceb08f81b955539d">GetFontWeight</a> (const <a class="el" href="../../da/d0e/class_text.html">Text</a> *text)</td></tr>
<tr class="memdesc:ae8599ff5bde69ad1ceb08f81b955539d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the font weight of a <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object as a string (e.g., "Normal", "Bold").  <br /></td></tr>
<tr class="separator:ae8599ff5bde69ad1ceb08f81b955539d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-static-methods" name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:abd4e33be5c6b2f9e92412f598da0a78c" id="r_abd4e33be5c6b2f9e92412f598da0a78c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4e33be5c6b2f9e92412f598da0a78c">UpdateUserAccumulator</a> (const std::string &amp;key, const std::string &amp;value, <a class="el" href="../../da/d30/struct_parser_1_1_raw_user.html">RawUser</a> &amp;acc)</td></tr>
<tr class="memdesc:abd4e33be5c6b2f9e92412f598da0a78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a <a class="el" href="../../da/d30/struct_parser_1_1_raw_user.html" title="Internal accumulator structure for parsing user account data from JSON.">RawUser</a> accumulator with a parsed key-value pair for user data.  <br /></td></tr>
<tr class="separator:abd4e33be5c6b2f9e92412f598da0a78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides functionality for parsing JSON data to C++ objects and vice-versa. </p>
<p>The <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> class handles the serialization and deserialization of various data structures used in the application, such as Shapes, UserAccounts, and Testimonials, converting them to and from JSON string representations. It includes methods for both forward parsing (JSON to object) and reverse parsing (object to JSON). This class does not store any data itself and its copy/move operations are disabled. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5208129b497bfdf7c8ecceeb70e4bba8" name="a5208129b497bfdf7c8ecceeb70e4bba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5208129b497bfdf7c8ecceeb70e4bba8">&#9670;&#160;</a></span>Parser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Initializes a <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> object. </p>

</div>
</div>
<a id="a95734193a58a199b4c6d820a6a730c42" name="a95734193a58a199b4c6d820a6a730c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95734193a58a199b4c6d820a6a730c42">&#9670;&#160;</a></span>~Parser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parser::~Parser </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. Cleans up resources used by the <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> object. </p>

</div>
</div>
<a id="a48044a8caa14a251cb4dad9fb363658e" name="a48044a8caa14a251cb4dad9fb363658e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48044a8caa14a251cb4dad9fb363658e">&#9670;&#160;</a></span>Parser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor to prevent copying <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects. </p>

</div>
</div>
<a id="aacd10e8fbc4e04201570a437198d8c61" name="aacd10e8fbc4e04201570a437198d8c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd10e8fbc4e04201570a437198d8c61">&#9670;&#160;</a></span>Parser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move constructor to prevent moving <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4947ae95392cd961660d9202d4c12e5e" name="a4947ae95392cd961660d9202d4c12e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4947ae95392cd961660d9202d4c12e5e">&#9670;&#160;</a></span>AppendBrushData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::AppendBrushData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends QBrush properties (BrushColor, BrushStyle) to a JSON string. </p>
<p>This helper function is used for shapes that have fill properties. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object whose brush data is to be serialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string containing the JSON representation of brush data. </dd></dl>

</div>
</div>
<a id="a8f8932bed758cd3e61de3669fdef1110" name="a8f8932bed758cd3e61de3669fdef1110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8932bed758cd3e61de3669fdef1110">&#9670;&#160;</a></span>AppendCommonShapeData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::AppendCommonShapeData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends common shape properties (ID, Type, Dimensions, Pen properties) to a JSON string. </p>
<p>This helper function is used during the serialization of shapes to JSON. It formats 9 common key-value pairs. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object to serialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string containing the JSON representation of common shape data. </dd></dl>

</div>
</div>
<a id="a3c8d6dcf6e07231eaedb036ebe90b51f" name="a3c8d6dcf6e07231eaedb036ebe90b51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8d6dcf6e07231eaedb036ebe90b51f">&#9670;&#160;</a></span>AppendTextData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::AppendTextData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends all properties specific to <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> objects to a JSON string. </p>
<p>Serializes properties like TextString, PointSize, Color, Alignment, Font. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object, expected to be a <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string containing the JSON representation of text data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the provided shape cannot be cast to <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a991032ca21e8e64a0fa274b8056cc669" name="a991032ca21e8e64a0fa274b8056cc669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991032ca21e8e64a0fa274b8056cc669">&#9670;&#160;</a></span>BuildShape()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/da7/class_shape.html">Shape</a> * Parser::BuildShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html">MorphicShape</a></td>          <td class="paramname"><span class="paramname"><em>tempShape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a concrete <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object from a populated <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> accumulator. </p>
<p>Based on the <code>shapeId</code> in <code>tempShape</code>, this function dynamically allocates and initializes the appropriate derived <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object (e.g., <a class="el" href="../../dd/db4/class_line.html" title="The Line class.">Line</a>, <a class="el" href="../../d0/d88/class_circle.html" title="The Circle class.">Circle</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tempShape</td><td>The <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> object containing the data for the new shape. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly instantiated <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object, or nullptr if construction fails. </dd></dl>

</div>
</div>
<a id="acabd71dccc533b85de37e566cda47abe" name="acabd71dccc533b85de37e566cda47abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabd71dccc533b85de37e566cda47abe">&#9670;&#160;</a></span>ExtractArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::ExtractArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a JSON array (content within '[]') as a string. </p>
<p>Assumes <code>index</code> is at the opening bracket of the array. Modifies <code>index</code> to point after the closing bracket of the array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string being parsed. </td></tr>
    <tr><td class="paramname">index</td><td>A reference to the current parsing index, modified by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted array (including brackets) as a std::string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the closing bracket is missing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30398a0f28f70626124609a1071f7f60" name="a30398a0f28f70626124609a1071f7f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30398a0f28f70626124609a1071f7f60">&#9670;&#160;</a></span>ExtractInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::ExtractInteger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an integer value from the JSON string. </p>
<p>Assumes <code>index</code> is at the first digit of the integer. Modifies <code>index</code> to point after the last digit of the integer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string being parsed. </td></tr>
    <tr><td class="paramname">index</td><td>A reference to the current parsing index, modified by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted integer as a std::string. </dd></dl>

</div>
</div>
<a id="a6658bb70a8b63f8edab2c0a6c7c65d9a" name="a6658bb70a8b63f8edab2c0a6c7c65d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6658bb70a8b63f8edab2c0a6c7c65d9a">&#9670;&#160;</a></span>ExtractKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::ExtractKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a JSON key (a string enclosed in double quotes) from the input string. </p>
<p>Assumes <code>index</code> is at the opening double quote of the key. Modifies <code>index</code> to point immediately after the closing double quote of the key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string being parsed. </td></tr>
    <tr><td class="paramname">index</td><td>A reference to the current parsing index, modified by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted key as a std::string. </dd></dl>

</div>
</div>
<a id="a9dbc99f343ea14baa4e3c8d84066b83e" name="a9dbc99f343ea14baa4e3c8d84066b83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbc99f343ea14baa4e3c8d84066b83e">&#9670;&#160;</a></span>ExtractLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::ExtractLiteral </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a JSON literal (true, false, null) as a string. </p>
<p>Assumes <code>index</code> is at the first character of the literal. Modifies <code>index</code> to point after the last character of the literal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string being parsed. </td></tr>
    <tr><td class="paramname">index</td><td>A reference to the current parsing index, modified by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted literal as a std::string. </dd></dl>

</div>
</div>
<a id="ade9641ed520d4e9b73600e3cc049af46" name="ade9641ed520d4e9b73600e3cc049af46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9641ed520d4e9b73600e3cc049af46">&#9670;&#160;</a></span>ExtractValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::ExtractValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts a JSON value from the input string. </p>
<p>Handles strings, numbers, arrays, and boolean literals. Modifies <code>index</code> to point after the extracted value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string being parsed. </td></tr>
    <tr><td class="paramname">index</td><td>A reference to the current parsing index, modified by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted value as a std::string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the value type is unexpected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34f89825a62c101002365cdc06188b0b" name="a34f89825a62c101002365cdc06188b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f89825a62c101002365cdc06188b0b">&#9670;&#160;</a></span>GetAlignmentFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetAlignmentFlag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d0e/class_text.html">Text</a> *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the text alignment of a <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object as a string (e.g., "AlignLeft", "AlignCenter"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>A constant pointer to the <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the text alignment. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the alignment flag is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ae1381ec08a2e3b54077c753d4dbf34" name="a2ae1381ec08a2e3b54077c753d4dbf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae1381ec08a2e3b54077c753d4dbf34">&#9670;&#160;</a></span>GetBrushStyle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetBrushStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the brush style of a shape as a string (e.g., "SolidPattern", "NoBrush"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the brush style. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the brush style is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a873d052551342d31e66e6746b09d2fe9" name="a873d052551342d31e66e6746b09d2fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873d052551342d31e66e6746b09d2fe9">&#9670;&#160;</a></span>GetColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetColor </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;</td>          <td class="paramname"><span class="paramname"><em>objectColor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a QColor object to its string representation (e.g., "red", "blue"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectColor</td><td>The QColor to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the color name. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the color is not one of the predefined known colors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a772810a8efbdda40d51d9a81125a45c0" name="a772810a8efbdda40d51d9a81125a45c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772810a8efbdda40d51d9a81125a45c0">&#9670;&#160;</a></span>GetFontStyle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetFontStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d0e/class_text.html">Text</a> *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the font style of a <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object as a string (e.g., "StyleNormal", "StyleItalic"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>A constant pointer to the <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the font style. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the font style is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8599ff5bde69ad1ceb08f81b955539d" name="ae8599ff5bde69ad1ceb08f81b955539d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8599ff5bde69ad1ceb08f81b955539d">&#9670;&#160;</a></span>GetFontWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetFontWeight </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d0e/class_text.html">Text</a> *</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the font weight of a <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object as a string (e.g., "Normal", "Bold"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>A constant pointer to the <a class="el" href="../../da/d0e/class_text.html" title="The Text class.">Text</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the font weight. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the font weight is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cc8c1d3938f5f55be6074830f96090e" name="a4cc8c1d3938f5f55be6074830f96090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc8c1d3938f5f55be6074830f96090e">&#9670;&#160;</a></span>GetPenCapStyle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetPenCapStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pen cap style of a shape as a string (e.g., "FlatCap", "RoundCap"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the pen cap style. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the pen cap style is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacdb18c8e63721594a5ee98f94e160c3" name="aacdb18c8e63721594a5ee98f94e160c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdb18c8e63721594a5ee98f94e160c3">&#9670;&#160;</a></span>GetPenJoinStyle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetPenJoinStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pen join style of a shape as a string (e.g., "MiterJoin", "BevelJoin"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the pen join style. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the pen join style is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af303a9796fe246709fd2da137248e6d2" name="af303a9796fe246709fd2da137248e6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af303a9796fe246709fd2da137248e6d2">&#9670;&#160;</a></span>GetPenStyle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetPenStyle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the pen style of a shape as a string (e.g., "SolidLine", "DashLine"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing the pen style. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the pen style is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af246a0732ef6c7518e5aaee1043d12e4" name="af246a0732ef6c7518e5aaee1043d12e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af246a0732ef6c7518e5aaee1043d12e4">&#9670;&#160;</a></span>GetShapeDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::GetShapeDimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d7/da7/class_shape.html">Shape</a> *</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the geometric dimensions of a shape as a JSON array string. </p>
<p>The specific dimensions depend on the shape type (e.g., coordinates for <a class="el" href="../../dd/db4/class_line.html" title="The Line class.">Line</a>, points for Polyline/Polygon, x,y,length,width for <a class="el" href="../../d9/dc7/class_rectangle.html" title="The Rectangle class.">Rectangle</a>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>A constant pointer to the <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::string representing a JSON array of the shape's dimensions. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the shape type is unknown or casting fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c4bd21d0d23be70682e026d6e702ec9" name="a9c4bd21d0d23be70682e026d6e702ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4bd21d0d23be70682e026d6e702ec9">&#9670;&#160;</a></span>JsonToShapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d7/da7/class_shape.html">Shape</a> * &gt; Parser::JsonToShapes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a JSON string representation into a vector of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> objects. </p>
<p>This is a forward parsing method that takes a JSON string, parses it, and constructs a vector of dynamically allocated <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>A constant reference to a string containing the JSON data for shapes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a> of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> pointers, each pointing to an instantiated <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the JSON string is malformed or parsing fails. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afde14aac82ddca80d32462cc085e71d9" name="afde14aac82ddca80d32462cc085e71d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde14aac82ddca80d32462cc085e71d9">&#9670;&#160;</a></span>JsonToTestimonials()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QVector&lt; <a class="el" href="../../d4/dc3/class_testimonial.html">Testimonial</a> &gt; Parser::JsonToTestimonials </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a JSON string representation into a QVector of <a class="el" href="../../d4/dc3/class_testimonial.html" title="Represents a user testimonial.">Testimonial</a> objects. </p>
<p>This static forward parsing method uses Qt's JSON utilities to parse testimonials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>A constant reference to a string containing the JSON data for testimonials. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A QVector of <a class="el" href="../../d4/dc3/class_testimonial.html" title="Represents a user testimonial.">Testimonial</a> objects. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If JSON parsing fails or the top-level structure is not an array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e0c6d8559fd28407b48e9eef05496d8" name="a7e0c6d8559fd28407b48e9eef05496d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0c6d8559fd28407b48e9eef05496d8">&#9670;&#160;</a></span>JsonToUsers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d3/d9d/class_user_account.html">UserAccount</a> * &gt; Parser::JsonToUsers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a JSON string representation into a vector of <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> objects. </p>
<p>This forward parsing method processes a JSON string to create <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>A constant reference to a string containing the JSON data for user accounts. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a> of <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> pointers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the JSON string is malformed or essential user data is missing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4492f2702ae0fc9e5b23a2fa546ee7f3" name="a4492f2702ae0fc9e5b23a2fa546ee7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4492f2702ae0fc9e5b23a2fa546ee7f3">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp; Parser::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator to prevent copying <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects. </p>

</div>
</div>
<a id="adfbcdfe39e81929129e00fba8b546ed9" name="adfbcdfe39e81929129e00fba8b546ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfbcdfe39e81929129e00fba8b546ed9">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp; Parser::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/db7/class_parser.html">Parser</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel delete">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move assignment operator to prevent moving <a class="el" href="../../dc/db7/class_parser.html" title="Provides functionality for parsing JSON data to C++ objects and vice-versa.">Parser</a> objects. </p>

</div>
</div>
<a id="a4d2c4035d6109be0ceca773cfbcff523" name="a4d2c4035d6109be0ceca773cfbcff523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2c4035d6109be0ceca773cfbcff523">&#9670;&#160;</a></span>ParseJsonObject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html">Parser::MorphicShape</a> Parser::ParseJsonObject </td>
          <td>(</td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses a single JSON object (data within '{}') into a <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a>. </p>
<p>This helper function processes one JSON object from the input string, extracting key-value pairs and populating a <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> accumulator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string being parsed. </td></tr>
    <tr><td class="paramname">index</td><td>A reference to the current parsing index within the JSON string, modified by the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> object containing the parsed data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the JSON object is malformed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae118a7f13833108b4f01902af8a260b8" name="ae118a7f13833108b4f01902af8a260b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae118a7f13833108b4f01902af8a260b8">&#9670;&#160;</a></span>PrintShapeVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::PrintShapeVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d7/da7/class_shape.html">Shape</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>shapes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints properties of shapes in a vector to the console. </p>
<p>Iterates through a vector of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> pointers and prints their ID, TrackerId, and ShapeType to standard output. Primarily for debugging purposes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shapes</td><td>A constant reference to an <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a> of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0dc74d228421b62ece9d9e93511509e" name="ac0dc74d228421b62ece9d9e93511509e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dc74d228421b62ece9d9e93511509e">&#9670;&#160;</a></span>ShapesToJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::ShapesToJson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d7/da7/class_shape.html">Shape</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>shapes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a vector of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> pointers into a JSON string representation. </p>
<p>This is a reverse parsing method that takes a vector of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> objects and serializes them into a JSON formatted string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shapes</td><td>A constant reference to an <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a> of <a class="el" href="../../d7/da7/class_shape.html" title="The Shape Abstract Base Class.">Shape</a> pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string formatted in JSON containing all key:value pairs for the shapes. </dd></dl>

</div>
</div>
<a id="a49fad6dc437bab644ea477090320cbe8" name="a49fad6dc437bab644ea477090320cbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fad6dc437bab644ea477090320cbe8">&#9670;&#160;</a></span>SkipWhitespace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::SkipWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>json</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the parsing index past any whitespace characters. </p>
<p>Modifies <code>index</code> to point to the next non-whitespace character in the <code>json</code> string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string being parsed. </td></tr>
    <tr><td class="paramname">index</td><td>A reference to the current parsing index, modified by the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a4c2a3664d2d2c1f5444c18271a1cf4" name="a0a4c2a3664d2d2c1f5444c18271a1cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4c2a3664d2d2c1f5444c18271a1cf4">&#9670;&#160;</a></span>StringToVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; int &gt; Parser::StringToVector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string representation of a JSON array of integers into an <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector&lt;int&gt;</a>. </p>
<p>Parses a string like "[20, 32, 41, 64]" into a vector of integers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string representation of the integer array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector&lt;int&gt;</a> containing the parsed integers. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the string format is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37a8828ed47a09c969ed966865da186d" name="a37a8828ed47a09c969ed966865da186d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a8828ed47a09c969ed966865da186d">&#9670;&#160;</a></span>TestimonialsToJson()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::TestimonialsToJson </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="../../d4/dc3/class_testimonial.html">Testimonial</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>testimonials</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a QVector of <a class="el" href="../../d4/dc3/class_testimonial.html" title="Represents a user testimonial.">Testimonial</a> objects into a JSON string representation. </p>
<p>This static reverse parsing method uses Qt's JSON utilities to serialize testimonials. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">testimonials</td><td>A constant reference to a QVector of <a class="el" href="../../d4/dc3/class_testimonial.html" title="Represents a user testimonial.">Testimonial</a> objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string formatted in JSON representing the testimonials. </dd></dl>

</div>
</div>
<a id="ac3bb64fa743348c1b31eb1118c6d4e0f" name="ac3bb64fa743348c1b31eb1118c6d4e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bb64fa743348c1b31eb1118c6d4e0f">&#9670;&#160;</a></span>UpdateAccumulator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::UpdateAccumulator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html">MorphicShape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tempShape</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> accumulator with a parsed key-value pair. </p>
<p>Converts the string <code>value</code> to its appropriate C++ type based on the <code>key</code> and stores it in the corresponding member of the <code>tempShape</code> accumulator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The JSON key as a string. </td></tr>
    <tr><td class="paramname">value</td><td>The JSON value as a string. </td></tr>
    <tr><td class="paramname">tempShape</td><td>A reference to the <a class="el" href="../../de/d34/struct_parser_1_1_morphic_shape.html" title="Internal accumulator structure for parsing shape data from JSON.">MorphicShape</a> accumulator to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the key is unknown or the value is invalid for the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4e33be5c6b2f9e92412f598da0a78c" name="abd4e33be5c6b2f9e92412f598da0a78c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4e33be5c6b2f9e92412f598da0a78c">&#9670;&#160;</a></span>UpdateUserAccumulator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::UpdateUserAccumulator </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d30/struct_parser_1_1_raw_user.html">RawUser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>acc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span><span class="mlabel private">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates a <a class="el" href="../../da/d30/struct_parser_1_1_raw_user.html" title="Internal accumulator structure for parsing user account data from JSON.">RawUser</a> accumulator with a parsed key-value pair for user data. </p>
<p>Converts the string <code>value</code> to its appropriate C++ type based on the <code>key</code> (username, password, admin) and stores it in the <code>acc</code> accumulator. Also sets flags in <code>acc</code> to indicate which fields were found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The JSON key as a string. </td></tr>
    <tr><td class="paramname">value</td><td>The JSON value as a string. </td></tr>
    <tr><td class="paramname">acc</td><td>A reference to the <a class="el" href="../../da/d30/struct_parser_1_1_raw_user.html" title="Internal accumulator structure for parsing user account data from JSON.">RawUser</a> accumulator to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the value for 'admin' is not "true" or "false". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec700c3508cbac1197ff4010160be3cb" name="aec700c3508cbac1197ff4010160be3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec700c3508cbac1197ff4010160be3cb">&#9670;&#160;</a></span>UsersToJson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Parser::UsersToJson </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a>&lt; <a class="el" href="../../d3/d9d/class_user_account.html">UserAccount</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>users</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a vector of <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> pointers into a JSON string representation. </p>
<p>This reverse parsing method serializes <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> objects into a JSON string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">users</td><td>A constant reference to an <a class="el" href="../../db/d35/classalpha_1_1vector.html">alpha::vector</a> of <a class="el" href="../../d3/d9d/class_user_account.html" title="Represents a user account within the application.">UserAccount</a> pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string formatted in JSON representing the user accounts. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/backend/<a class="el" href="../../de/d40/_parser_8h_source.html">Parser.h</a></li>
<li>src/backend/<a class="el" href="../../de/df6/_parser_8cpp.html">Parser.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dc/db7/class_parser.html">Parser</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
